import React from 'react';
import cn from 'classnames';

export default class Carousel extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      active: 0,
    };
  }

  prevBtn = (event) => {
    event.preventDefault();

    this.setState(({ active }) => {
      if (active <= 0) {
        return { active: this.props.images.length - 1 };
      }

      return { active: active - 1 };
    });
  };

  nextBtn = (event) => {
    event.preventDefault();

    this.setState(({ active }) => {
      if (active >= (this.props.images.length - 1)) {
        return { active: 0 };
      }

      return { active: active + 1 };
    });
  };

  renderCarouselItems () {
    return (
      <React.Fragment>
        {this.props.images.map((imgPath, index) => {
          const carouselItemClass = cn('carousel-item', {
            active: this.state.active === index,
          });

          return (
            <div key={index} className={carouselItemClass}>
              <img alt='' className='d-block w-100' src={imgPath} />
            </div>
          );
        })}
      </React.Fragment>
    );
  }

  render () {
    return (
      <div id='carousel' className='carousel slide' data-ride='carousel'>
        <div className='carousel-inner'>
          {this.renderCarouselItems()}
        </div>
        <a className='carousel-control-prev' href='#carousel' role='button' data-slide='prev' onClick={this.prevBtn}>
          <span className='carousel-control-prev-icon'></span>
          <span className='sr-only'>Previous</span>
        </a>
        <a className='carousel-control-next' href='#carousel' role='button' data-slide='next' onClick={this.nextBtn}>
          <span className='carousel-control-next-icon'></span>
          <span className='sr-only'>Next</span>
        </a>
      </div>
    );
  }
}

/*

 renderItems() {
    const { currentIdx, images } = this.state;
    return images.map(({ url, key }, id) => {
      const classes = cn({
        'carousel-item': true,
        active: currentIdx === id,
      });
Откуда берется id, которое передается в map? Я так понимала,
что мы в map перебираем элементы images, откуда у них
появился атрибут id?

в колбек метода map можно передавать не только текущий
элемент массива, но и его индекс: 


Впервые вижу такую запись, объясните, пожалуйста, как она работает:

Code (possible spoiler)
const nextIdx = ((currentIdx + 1) % images.length);

По смыслу я понимаю, что тут должно по идее происходить: если
текущий индекс активного элемента равен пограничному значению:
первое или последнее, то новым текущим индексом становится последний
или первый соответственно. Но не понятно... Спасибо!

согласен хитрая формула, но тут не только пограничные случаи,
например если у нас 4 элемента текущий индекс 2 то 2 + 1 и взять
остаток от деления на 4 = 3 таким образом при срабатывании события
индекс увеличился на 1 от текущего, а если пограничный случай то
4 + 1 и взять остаток от деления на 4 = 1, можно конечно просто
увеличивать на 1 но тогда надо вводить проверку для пограничных
случаев.


Подскажите как локально картинки в реакте загружать через вебпак или
как сборка в упражнении происходит?

Через вебпак. В упражнении этого не видно, но там тоже всё работает
через вебпак

Пока не понял как автоматом сделать, можете подсказать? Только через
импорты работает
import first from '../public/images/first.jpg'
Конфиг вебпака test: /.(png|svg|jpg|gif)$/, use: ['file-loader'],

В упражнении вебпак выступает в роли сервера. При запуске, он
предоставляет браузеру файлы для доступа, так как сам браузер не имеет
прямого доступа к файловой системе. Сами же файлы могут подключаться в
шаблонах или скриптах. Вы должны указать используемые ресурсы, иначе
на них невозможно ссылаться.


Я не понимаю для чего в state записан массив с картинками? Он же не
меняется.
Code (possible spoiler)

this.state = {
      currentIdx: 0,
      // картинки могут повторяться, key должен быть уникальным
      images: images.map((url) => ({ url, key: uniqueId() })),
    };

В данном упражнении конечно можно и не хранить эти данные в стейте. Но
в целом это нормальная практика, когда все данные хранятся в стейте.
На практике такие данные часто приходят с сервера. Рекомендую
дополнительно повторить урок


Если использовать индексы в качестве ключей, и, например, добавить в
начало коллекции новый элемент, все индексы после него изменятся, хотя
сами элементы останутся теми же - это приведёт к лишней отрисовке.
Для дебага реакт-приложений можно использовать react-devtools, об этом
расширении для браузера упоминалось в первом уроке курса.


почему такой способ работы не нужен? Что значит явное управление потоком
событий? Что такое консистентные свойства? Что за событие onChange?

обработчики в реакте добавляются определением соответствующих свойств у
компонентов, например:

Code (possible spoiler)
<button onClick={handleClick} />

Всё, это единственный способ обработки событий, нельзя в произвольном
месте добавить обработчик, как это делается в нативном js.

События в реакте являются обёрткой над нативными событиями, эта обёртка
работает одинаково во всех браузерах, в этом состоит консистентность.

Вспомните, как работает событие change в js. Так вот, onChange работает
по-другому, этот колбек будет вызван при каждом изменении содержимого
инпута.


    И еще вопрос: почему линтер ругается на использование индекса
    массива как уникального ключа при работе с коллекцией?

если поменяется порядок элементов (при сортировке, например) или
элементы будут добавлены/удалены, индексы поменяются и это приведёт
к перерисовке элементов под этими индексами, даже если сами
элементы не изменятся. Поэтому использовать индексы не
рекомендуется. Кстати, если вы не укажете key для элементов
коллекции, React использует как раз индексы массива за неимением
лучшего варианта.


Здравствуйте, подскажите пожалуйста, зачем мы указываем еще и url?
Ведь uniqueId() итак дает уникальное значение, в чем смысл? Решил
проверить без url, код также выполняется, проверка проходит, но
время проверки задания сильно увеличивается, неужели это нужно для
облегчения нагрузки? Код прилагаю ниже, спасибо. ${url}_${_.uniqueId()};

Достаточно uniqueId.


constructor(props) { super(props); const { images } = props; }


перезагрузка страницы не является дефолтным поведением при нажатии
на ссылку. Когда вы кликаете по ссылке, браузер переходит по этой
ссылке. В случае со ссылкой, ведущей на элемент на этой же странице
(якорь) документ будет прокручен так, что элемент попадёт в поле
видимости. Например, в этом упражнении, если бы документ был больше
по высоте, чем экран, и слайдер частично был бы вне поля видимости,
нажатие на ссылку без preventDefault приводило бы к прокрутке.
Тесты это не проверяют.
*/
