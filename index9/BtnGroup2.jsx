import React from 'react';
import cn from 'classnames';

export default class BtnGroup extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      active: 'none',
    };
  }

  activeLeftBtn = () => {
    this.setState(({ active }) => ({ active: 'left' }));
  };

  activeRightBtn = () => {
    this.setState(({ active }) => ({ active: 'right' }));
  };

  render () {
    const leftBtnClass = cn('btn', 'btn-secondary', 'left', {
      active: this.state.active === 'left',
    });
    const rightBtnClass = cn('btn', 'btn-secondary', 'right', {
      active: this.state.active === 'right',
    });

    return (
      <div className='btn-group' role='group'>
        <button type='button' className={leftBtnClass} onClick={this.activeLeftBtn}>Left</button>
        <button type='button' className={rightBtnClass} onClick={this.activeRightBtn}>Right</button>
      </div>
    );
  }
}

/*
Вам нужно, при клике на любую из кнопок, менять состояние не только
для кнопки по которой кликнули, но и состояние другой кнопки. Тогда,
при перерисовке, будут меняться обе кнопки. Либо вы можете немного
доработать решение, убрать отдельные состояние кнопок, а сделать
одно, в котором бы хранился тип нажатой кнопки (например left или
right)


Здравствуйте, объясните пожаулйста в какой момент в решении учителя
происходит убирание класс active если нажата другая кнопка?Я этого
не понял

Это происходит сразу при нажатии. В момент нажатия, например на левую
кнопку, в состоянии сохраняется { active: 'left' }. После этого
состояние перерисовывается, берётся значение active и устанавливаются
классы в зависимости от проверок условий active === 'left' и
active === 'right'.


Добрый день! Вот нашел статью с аргументами против использования
стрелочных функций в качестве методов класса. Не лучше все-таки биндить
контекст в конструкторе?
https://medium.com/@charpeni/arrow-functions-in-class-properties-might-not-be-as-great-as-we-think-3b3551c440b1

Code (possible spoiler)
    constructor(props) {
        super(props);
        this.сlickHandle = this.сlickHandle.bind(this);
    }

Статья скорее о том, как бабель транспилирует код. В комментариях к
статье, кстати, есть ссылка на плагин для бабеля, который преобразует
стрелочные функции и биндит их в конструкторе. Со стрелочными функциями
код более читаемый, что тоже не очень важно. Поэтому это довольно спорный
момент.


Хотелось бы уточнить несколько моментов из теории:
В примере ниже - зачем и почему мы передаем props в конструктор и super?

Code (possible spoiler)

class Clock extends React.Component {
  constructor(props) {
    super(props); // всегда обязательно
    this.state = { date: new Date() };
  }
}

И дальше в теории мы опять передаем prop, но он вроде бы нигде не используется.
Зачем его передавать тогда?

Code (possible spoiler)

this.setState((state, props) => {
  const { count } = state;
  return { count: count + 1 };
})

Компоненты реакта наследуются от React.Component, у этого класса есть свой
конструктор, который вызывается с помощью super(), в него мы должны передать
props, чтобы в нашем классе было доступно свойство this.props. Такая механика
часто используется, когда мы расширяем базовый класс и добавляем свою логику.
Получается что мы к уже существующей логике из базового класса, добавляем
свою. Но чтобы вызвать методы из базового класса нам нужно использовать
super(он даёт доступ к методам родительского класса).

Передача props в колбеке сделано просто для удобства - это гарантирует доступ
ко всем необходимым данным для обновления состояния. Передавать его не
обязательно(более того не обязательно использовать колбек), но мы не могли
его не добавить в теорию: так как такая возможность существует, то её
обязательно нужно показать.


Разжуйте пожалуйста вот этот момент:

Вторая причина связана с производительностью. Оба предыдущих примера
передачи обработчика порождают при каждом вызове функции render новые
обработчики (так как функции сравниваются по ссылкам, а не по содержимому),
а для React это критично.

при каждом вызове функции render будут создаваться новые
функции-обработчики (а не переиспользоваться созданные на предыдущем вызове)
и передаваться в пропсы. Когда изменяются пропсы, Реакт считает, что
компонент изменился (даже если фактически пропсы идентичны) и запускает цикл
перерисовки этого компонента.

this.handleClick.bind(this) === this.handleClick.bind(this);
false

this.handleClick === this.handleClick;
true

Про ссылочные типы данных знаю: "Object, Array и Function это ссылочные типы
данных. Ввиду того что они могут содержать очень большие объемы данных,
переменная, содержащая ссылочный тип, не содержит его значения. Она содержит
ссылку на место в памяти, где размещаются реальные данные."

вызов bind на функции возвращает новую функцию. Если вызвать bind на функции,
сохранить в переменную, потом вызвать снова bind на функции, сохранить в
другую переменную и затем эти переменные сравнить, то они будут неравны.
Именно потому, что функции передаются по ссылке и это будут две разные ссылки.

все понял. Объясните пожалуйста еще вот этот момент:
"При каждом вызове функции render будут создаваться новые функции-обработчики
и передаваться в пропсы" - согласно уроку, пропсы передаются как атрибуты в
HTML (<HelloMessage name="Kate" />). Как это работает в нашем случае?

пропсы передаются как пропсы. Вспомните урок про jsx, что такое вообще jsx?
Если компонент является встроенным компонентом (div, span, h1 и т.д.), то
пропсы могут стать его html-атрибутами.

получается что onClick={this.handleClick} это пропс тега button?

Просто, до этого момента, я думал что props это объект с информацией, который
передается в компонент извне на стадии ReactDOM.render. Здесь совершенно
другая история. Что я недопонимаю?

Если onClick передан в button, то да, это пропс button. ReactDOM не имеет
никакого отношения к пропсам, это библиотека для рендеринга React-приложения
в браузере. Возможно, вам стоит ещё раз перечитать теоретическую часть уроков
про jsx и props.

перечитал. Какое бы вы дали определение пропсам? Чем отличается пропс от
атрибута в HTML

начнём с того, что JSX - это не HTML. JSX является синтаксическим сахаром над
React.createElement(component, props, ...children). Props - это данные, которые
могут использоваться для конфигурирования компонента и в том числе могут
определять HTML атрибуты для встроенных компонентов. JSX удобнее, чем явный
вызов указанной выше функции, но это всё ещё не HTML.
*/


